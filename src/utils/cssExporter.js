/**
 * CSS Exporter Utility
 * Generates production-ready CSS from typography settings
 */

/**
 * Generate @font-face declarations
 */
function generateFontFaceRules(fonts, includeFontFace, fontScales) {
    if (!includeFontFace) return '';

    const rules = [];

    fonts.forEach(font => {
        if (font.fontUrl && font.fileName) {
            const fontFamily = font.fileName.replace(/\.[^/.]+$/, ''); // Remove extension
            const isFallback = font.type === 'fallback';

            // Use font-specific scale if set, otherwise use global fallback scale
            let sizeAdjust = 1; // Default for primary fonts
            if (isFallback) {
                // Check if this font has a specific scale override, otherwise use global
                sizeAdjust = (font.scale ?? fontScales.fallback) / 100;
            }

            rules.push(`@font-face {
  font-family: '${fontFamily}';
  src: url('${font.fontUrl}') format('truetype');
  font-display: swap;
  size-adjust: ${Math.round(sizeAdjust * 100)}%;
}`);
        }
    });

    return rules.length > 0 ? `/* Font Face Declarations */\n${rules.join('\n\n')}\n\n` : '';
}

/**
 * Generate header styles
 */
function generateHeaderStyles(headerStyles, baseFontSize) {
    const rules = [];

    Object.entries(headerStyles).forEach(([tag, style]) => {
        const fontSize = Math.round(style.scale * baseFontSize);
        rules.push(`${tag} {
  font-size: ${fontSize}px;
  line-height: ${style.lineHeight};
}`);
    });

    return `/* Header Styles */\n${rules.join('\n\n')}\n\n`;
}

/**
 * Generate fallback font line-height overrides
 */
function generateFallbackFontLineHeights(context) {
    const { fonts, lineHeight } = context;

    const fallbackFonts = fonts.filter(f => f.type === 'fallback');
    if (fallbackFonts.length === 0) return '';

    const rules = [];

    fallbackFonts.forEach(font => {
        // Only generate if this font has a line-height override
        if (font.lineHeight && font.lineHeight !== lineHeight) {
            const fontFamily = font.fileName?.replace(/\.[^/.]+$/, '') || 'sans-serif';
            const className = fontFamily.toLowerCase().replace(/[^a-z0-9]/g, '-');

            rules.push(`.font-${className} {
  line-height: ${font.lineHeight};
}`);
        }
    });

    return rules.length > 0 ? `/* Fallback Font Line Height Overrides */\n${rules.join('\n\n')}\n\n` : '';
}

/**
 * Generate language-specific overrides
 */
function generateLanguageOverrides(context, languages) {
    const { fallbackFontOverrides, fonts } = context;

    if (Object.keys(fallbackFontOverrides).length === 0) return '';

    const rules = [];

    Object.entries(fallbackFontOverrides).forEach(([langId, fontId]) => {
        const language = languages.find(l => l.id === langId);
        if (!language) return;

        const font = fonts.find(f => f.id === fontId);
        if (!font) return;

        const fontFamily = font.fileName?.replace(/\.[^/.]+$/, '') || 'sans-serif';
        const lineHeightValue = font.lineHeight || context.lineHeight;

        rules.push(`[lang="${language.code}"] {
  font-family: '${fontFamily}', sans-serif;
  line-height: ${lineHeightValue};
}`);
    });

    return rules.length > 0 ? `/* Language-Specific Overrides */\n${rules.join('\n\n')}\n` : '';
}

/**
 * Main CSS generation function
 */
export function generateCSS(context, languages = [], options = {}) {
    const {
        includeFontFace = false,
        includeComments = true,
        prettyPrint = true
    } = options;

    let css = '';

    // Add header comment
    if (includeComments) {
        css += `/* Generated by Localize Type */\n/* ${new Date().toISOString()} */\n\n`;
    }

    // Generate sections
    css += generateFontFaceRules(context.fonts, includeFontFace, context.fontScales);
    css += generateHeaderStyles(context.headerStyles, context.baseFontSize);
    css += generateFallbackFontLineHeights(context);
    css += generateLanguageOverrides(context, languages);

    // Minify if needed
    if (!prettyPrint) {
        css = css.replace(/\s+/g, ' ').replace(/\n/g, '').trim();
    }

    return css;
}
